{
	// MASTER REGEX SEQUENCE must be named "REGEX_SEQUENCE"
	// 'REGEX_SEQUENCE' may be a list of explisit steps (dict) or/and subsequences names.
	// Subsequences should be listed below in the same dict
	"REGEX_SEQUENCE" : [
		{
			// regex
			// "FIND" : "@property(?:\\(.+?\\))?\\s*?(\\w+\\s*\\*)\\s*(\\w+);",
			"FIND_ALL" : "@property(?:\\(.+?\\))?\\s*?(\\w+\\s*\\*)\\s*(\\w?)(\\w*);",

			// unique matches, available grobaly for every step after the step
			// when the tokens were defined.
			// Tokens may be used in replace patterns with format ${token_name}
			"TOKENS" : {
				// token name as a key, and first group ($1) as its value.
				// If there is no group the whole match
				// will be used as a token value
				// If more then one match the first one will be used
				"class" : "@interface (\\w+)\\s*:"
			},

			// regex
			// "FIND" : "(?P<type>\\w+\\s*\\*);(\\w)(\\w*)",

			// no "REPLACE" node will cause replacing all content by "FIND" rezult
			// "REPLACE" : "FOUNDATION_EXPORT $1 const kPropertyName\\U$2\\E$3;"
			// "REPLACE" : "FOUNDATION_EXPORT $1 const kPropertyName\\U$2\\E$3;"
		},
		"Generate output"
	],

	// Enable printing the result of each step with comments instead of
	// the result of whole sequence
	"DEBUG" : true, // default value is false

	// ATOMIC STEPS SEQUENCES (reusable in other sequences):
	"Generate output" : [
		{
			// regex
			"FIND" : "@property(?:\\(.+?\\))?\\s*?(\\w+\\s*\\*)\\s*(\\w?)(\\w*);",
			"REPLACE" : [
				"const export",
				"const",
				"synthesize"
			]
		}
	],
	"REPLACE_PATTERNS" : {
		"const export" : "FOUNDATION_EXPORT NSString* const kPropertyName\\U$2\\E$3;",
		"const" : "NSString* const k${class}\\U$2\\E$3 = @\"${class}\\U$2\\E$3\";",
		"synthesize" : "@synthesize \\U$2\\E$3;"
	}
}