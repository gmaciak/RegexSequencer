[
	{
		"id" : "regex_sequencer",
		"caption" : "Regex Sequencer",
		"children":
		[
			{
				// You can override 'sample_sequence' by defining your own sequence
				// for id 'sample_sequence'.
				// To do so, you need to:
				// 1. open menu: 'Sublime Text/Preferences/Regex Sequencer/Context Menu â€“ User'
				// 2. if file is empty copy content of this file to it
				// 3. define your own sequence with 'id' : 'sample_sequence'
				// 4. set your own 'caption' and 'args'
				"id" : "sample_sequence",
				"caption" : "Sample Sequence",
				"command" : "regex_sequencer",
				"args" : {
					// Sample Sequence generates some other parts of class definition
					// according to defined header file written in Objective-C language
					// e.g:
					/*
						#import <Foundation/Foundation.h>
						#import "SomeProtocol.h"

						@interface XXXSomeClass : NSObject <SomeProtocol>

						@property NSDictionary* json;
						@property(nonatomic,copy)  NSString* output_Key;
						@property(nonatomic,copy) NSString * title;
						@property(nonatomic,retain) NSArray* items;

						@end
					*/
					// CLICK ON THE FILE AND FIRE "Sample Sequence" COMMAND FROM CONTEXT MENU TO FIND OUT

					// MASTER REGEX SEQUENCE must be named "REGEX_SEQUENCE"
					// 'REGEX_SEQUENCE' may be a list of explisit steps (dict) or/and subsequences names.
					// Subsequences should be listed below in the same dict
					"REGEX_SEQUENCE" : [
						{
							// regex
							

							// Step with FIND_ALL will find all elements matching
							// to pattern and replace all content with the result
							// FIND_ALL has greater priority than find
							// Every pattern may be defined directly after FIND, FIND_ALL or in
							// REGULAR_EXPRESSIONS node and then used by name multiple times
							"FIND_ALL" : "property",

							// If there is no REPLACE key in the step, FIND works the same as FIND_ALL
							// "FIND" : "@property(?:\\(.+?\\))?\\s*?\\w+\\s*\\*\\s*\\w+;",

							// unique matches, available grobaly for every step from the step
							// when the tokens were defined.
							// Tokens may be used in replace patterns with format ${token_name}
							"TOKENS" : {
								// token name as a key, and first group ($1) as its value.
								// If there is no group the whole match
								// will be used as a token value
								// If more then one match the first one will be used
								"class" : "@interface (\\w+)\\s*:"
							},

							// If no "REPLACE" node will cause replacing all content by FIND or FIND_ALL result
							// "REPLACE" : [
							// 	"const export",
							// 	"const",
							// 	"synthesize"
							// ]
						},

						// Every next step is performed on the result of previous step
						// Steps may by defined directly or globaly
						// in the main node and then used by name multiple times
						"Generate output"
					],

					// Enable printing the result of each step with comments instead of
					// the result of whole sequence
					"DEBUG" : true, // default value is false

					// ATOMIC STEPS SEQUENCES (reusable in other sequences):
					"Generate output" : [
						{
							// regex
							"FIND" : "property",
							"REPLACE" : [
								"const export",
								"const",
								"synthesize"
							]
						}
					],

					"REGULAR_EXPRESSIONS" : {
						"property" : "@property(?:\\(.+?\\))?\\s*?(\\w+\\s*\\*)\\s*(\\w?)(\\w*);"
					},

					// GLOBAL replace templates
					"REPLACE_TEMPLATES" : {
						"const export" : "FOUNDATION_EXPORT NSString* const kPropertyName\\U$2\\E$3;",
						"const" : "NSString* const k${class}\\U$2\\E$3 = @\"${class}\\U$2\\E$3\";",
						"synthesize" : "@synthesize \\U$2\\E$3;"
					}
				}
			}
		]
	}
]